import java.util.Collection;
import java.math.*;

import jaima.game.Move;
import jaima.game.Player;
import jaima.game.State;

public class penteState extends State {

	String string = "";
	boolean isFive = false;
	int captureW = 0;
	int captureB = 0;
	int counter = 0;
	pentePlayer[] players;
	char[] board;
	char[][] twoDBoard;
	int size;
	int diameter;
	int startingx;
	int startingy;
	char currentColor;

	public penteState(String s, int size) {
		super(s);

		if (players == null) {
			players = new pentePlayer[] { new pentePlayer('W'),
					new pentePlayer('B'), };
		}

		this.size = size;
		int stringCounter = 0;
		diameter = (int) Math.sqrt(size);
		for (int i = 0; i < diameter; i++) {
			for (int j = 0; j < diameter; j++) {
				twoDBoard[i][j] = s.charAt(stringCounter);
				stringCounter++;
			}
		}

		board = s.toUpperCase().toCharArray();
	}

	public String toString() {
		return string;
	}

	@Override
	public State clone() {
		penteState newState = new penteState(this.string, size);
		return newState;
	}

	@Override
	public Collection<Move> actions() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public boolean terminal() {
		if(isFive == true)
		{
			return true;
		}
		if (captureW >= 5) {
			return true;
		}
		if (captureB >= 5) {
			return true;
		}

		return false;
	}

	public double utility(Player p) {
		// TODO Auto-generated method stub
		return 0;
	}

	public Player toMove() {
		int b = charCount('B');
		int w = charCount('W');
		int toMove = (b <= w) ? 0 : 1;
		return players[toMove];
	}

	private int charCount(char m) {
		int count = 0;
		for (char c : board)
			if (c == m)
				count++;
		return count;
	}

	public State result(Move m) {
		penteMove n = (penteMove) m;
		int r = n.row();
		int c = n.col();
		// int i = index(r, c);
		State s = clone();
		s.penteState[i] = toMove().toString().charAt(0);
		return s;
	}


	
	public void isCapture(int x, int y, char color)
	{
		
	}

	public boolean isfive(int x, int y, char color) {
        currentColor = color;
      if (fiveChecker(x,y,color,1,0 ) >= 5)
    	  {	
    	  	isFive = true;
    	  	return true;
    	  }
      if (fiveChecker(x,y,color,0, 1) >= 5)
      {
    	  isFive = true;
         return true;
      }
      if (fiveChecker(x,y,color,1, -1 ) >= 5)
      {
    	  isFive = true;
         return true;
      }
      if (fiveChecker(x,y,color,1, 1 ) >= 5)
      {
    	  isFive = true;
         return true;
      }
      return false;
	}

	// public enum Direction {
	// UP, UPRIGHT, UPLEFT, LEFT, RIGHT, DOWN, DOWNRIGHT, DOWNLEFT
	// }

	public int fiveChecker(int x, int y, char color, int directionX,
			int directionY) {
		int xpos;
		int ypos;
		xpos = x;
		ypos = y;
		counter = 1;
		ypos = y + directionY;
		xpos = x + directionX;
		while (ypos >= 0 && xpos >= 0 && ypos < diameter && xpos < diameter
				&& twoDBoard[ypos][xpos] == color) {
			counter++;
			ypos += directionY;
			xpos += directionX;
		}

		ypos = y - directionY;
		xpos = x - directionX;
		while (ypos >= 0 && xpos < diameter && xpos >= 0 && ypos < diameter
				&& twoDBoard[ypos][xpos] == color) {
			counter++;
			ypos -= directionY;
			xpos -= directionX;
		}
		return counter;

		// my algorithm was way to complicated decided to try a different route
		// if (counter <= 4 && direction == direction.UP && color != 'X') {
		// if (twoDBoard[xpos][ypos - diameter] == color) {
		// counter++;
		// fiveChecker(direction.UP, xpos,ypos - diameter, color);
		// return true;
		//
		// } else {
		// counter = 0;
		// return false;
		// }
		// }
		// if (counter <= 4 && direction == direction.DOWNLEFT && color != 'X')
		// {
		// if (twoDBoard[ypos + diameter][xpos - 1] == color) {
		// counter++;
		// fiveChecker(direction.DOWNLEFT, xpos -1,ypos + diameter, color);
		//
		// return true;
		// } else {
		// counter = 0;
		// return false;
		// }
		// }
		// if (counter <= 4 && direction == direction.DOWNRIGHT && color != 'X')
		// {
		// if (twoDBoard[xpos + 1][ypos + diameter] == color) {
		// counter++;
		// fiveChecker(direction.DOWNRIGHT, xpos,ypos - diameter, color);
		//
		// return true;
		// } else {
		// counter = 0;
		// return false;
		// }
		// }
		// if (counter <= 4 && direction == direction.UPLEFT && color != 'X') {
		// if (twoDBoard[xpos - 1][ypos - diameter] == color) {
		// counter++;
		// fiveChecker(direction.UPLEFT, xpos,ypos - diameter, color);
		//
		// return true;
		// } else {
		// counter = 0;
		// return false;
		// }
		// }
		// if (counter <= 4 && direction == direction.UPRIGHT && color != 'X') {
		// if (twoDBoard[xpos + 1][ypos - diameter] == color) {
		// counter++;
		// fiveChecker(direction.UPRIGHT, xpos,ypos - diameter, color);
		//
		// return true;
		// } else {
		// counter = 0;
		// return false;
		// }
		// }
		// if (counter <= 4 && direction == direction.LEFT&& color != 'X') {
		// if ( xpos-1 != startingx && twoDBoard[xpos - 1][ypos] == color ) {
		// counter++;
		// fiveChecker(direction.LEFT, xpos,ypos - diameter, color);
		//
		// return true;
		// } else {
		// counter = 0;
		// return false;
		// }
		// }
		// if (counter <= 4 && direction == direction.RIGHT && color != 'X') {
		// if (twoDBoard[xpos + 1][ypos] == color) {
		// counter++;
		// fiveChecker(direction.RIGHT, xpos +1,ypos, color);
		//
		// return true;
		// }
		// else{
		// counter = 0;
		// return false;
		// }
		// }
		// if (counter <= 4 && direction == direction.DOWN && color != 'X') {
		// if (twoDBoard[xpos][ypos + diameter] == color) {
		// counter++;
		// fiveChecker(direction.DOWN, xpos,ypos + diameter, color);
		//
		// return true;
		// } else {
		// counter = 0;
		// return false;
		// }
		// } else
		// return false;

	}
}
