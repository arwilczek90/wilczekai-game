#BlueJ class context
comment0.params=
comment0.target=java.lang.String\ toString()
comment0.text=\r\n\ You\ MUST\ define\ a\ compact\ string\ conversion.\ \r\n\ @return\ a\ string\ that\ identifies\ the\ state.\r\n\ If\ s1\ and\ s2\ are\ two\ different\ states,\r\n\ \!s1.toString().equals(s2.toString())\ .\r\n\ If\ s1\ and\ s2\ are\ equivalent,\ though,\r\n\ s1.toString().equals(s2.toString())\ .\r\n
comment1.params=indent
comment1.target=java.lang.String\ prettyPrint(java.lang.String)
comment1.text=\r\n\ Optionally,\ you\ may\ redefine\ this\ method.\r\n\ @return\ an\ ASCII\ art\ representation\ of\ the\ state.\r\n
comment10.params=m
comment10.target=State\ result(Move)
comment10.text=\r\n\ @return\ the\ state\ resulting\ from\ a\ move\r\n
comment11.params=s
comment11.target=int\ compareTo(State)
comment11.text=\r\n\ This\ method\ is\ required,\ so\ that\ States\ can\ be\ stored\ in\r\n\ an\ ordered\ structure\ such\ as\ a\ TreeMap.\r\n\ You\ may\ overload\ it\ for\ efficiency,\r\n\ but\ the\ method\ below\ should\ work\ as\ it\ is.\r\n
comment12.params=s
comment12.target=boolean\ equals(java.lang.Object)
comment12.text=\r\n\ This\ method\ is\ required,\ so\ that\ States\ can\ be\ stored\ in\r\n\ an\ ordered\ structure\ such\ as\ a\ TreeMap.\r\n\ You\ may\ overload\ it\ for\ efficiency,\r\n\ but\ the\ method\ below\ should\ work\ as\ it\ is.\r\n
comment13.params=
comment13.target=int\ hashCode()
comment14.params=prefix\ depth\ p
comment14.target=void\ printSuccessors(java.lang.String,\ int,\ Player)
comment15.params=depth
comment15.target=void\ printSuccessors(int)
comment16.params=
comment16.target=void\ printSuccessors()
comment2.params=
comment2.target=java.lang.String\ prettyPrint()
comment2.text=\r\n\ Optionally,\ you\ may\ redefine\ this\ method.\r\n\ @return\ an\ ASCII\ art\ representation\ of\ the\ state.\r\n
comment3.params=fromString
comment3.target=State(java.lang.String)
comment3.text=\r\n\ You\ MUST\ overload\ this\ method\r\n\ with\ a\ method\ that\ produces\ a\ valid\ State.\r\n\ @param\ fromString\ a\ compact,\ \r\n\ precise\ description\ of\ the\ state.\r\n\ It\ MUST\ be\ true\ that\:\r\n\ <pre>\r\n\ \ \ \ \ \ \ \ String\ v\ \=\ "...";\ \ \ //\ a\ valid\ state\ representation\r\n\ \ \ \ \ \ \ \ State\ s\ \=\ new\ State(v);\r\n\ \ \ \ \ \ \ \ String\ w\ \=\ s.toString();\r\n\ \ \ \ \ \ \ \ assertEquals(v,\ w);\r\n\ \ \ \ \ \ \ </pre>\r\n
comment4.params=
comment4.target=State()
comment4.text=\r\n\ A\ state\ created\ from\ an\ empty\ string\ should\ have\r\n\ a\ fresh\ game\ board,\ with\ an\ arbitrary\ player\r\n\ chosen\ to\ move\ first.\r\n
comment5.params=
comment5.target=State\ clone()
comment5.text=\r\n\ Most\ of\ you\ should\ implement\ the\ clone()\ method.\r\n\ A\ state\ will\ not\ work\ properly\ in\ a\ search\ tree\ \r\n\ unless\ clone()\ returns\ a\ deep\ copy.\r\n\ @return\ an\ identical\ State\r\n
comment6.params=
comment6.target=java.util.Collection\ actions()
comment6.text=\r\n\ You\ must\ return\ a\ collection\ of\ all\ legal\ moves\ \r\n\ from\ this\ state,\ with\ no\ duplicates.\r\n\ @return\ a\ collection\ of\ moves\r\n
comment7.params=
comment7.target=boolean\ terminal()
comment7.text=\r\n\ You\ must\ correctly\ determine\ whether\ a\ state\ is\r\n\ final\ (a\ win,\ tie,\ draw)\ or\ not.\r\n\ @return\ true\ if\ a\ state\ is\ final,\ false\ if\ not\r\n
comment8.params=p
comment8.target=double\ utility(Player)
comment8.text=\r\n\ @param\ p\ the\ player\ who\ is\ applying\ the\ strategy\r\n\ @return\ the\ true\ value\ of\ a\ terminal\ state,\r\n\ or\ the\ estimates\ value\ of\ a\ nonterminal\r\n\ positive\ values\ are\ winning\r\n
comment9.params=
comment9.target=Player\ toMove()
comment9.text=\r\n\ @return\ the\ player\ who\ has\ the\ next\ move\r\n
numComments=17
